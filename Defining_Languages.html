<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>Defining Languages</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="racket.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-style.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-racket.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript">
(function() {
  document.write('<link rel="stylesheet" href="katex/katex.min.css" />');
})();(function() {document.write('<scr' + 'ipt type="text/javascript" src="katex/katex.min.js"></scr' + 'ipt>');})();(function(f) {
  // A "simple" onLoad function
  if (window.document.readyState == "complete") {
    f();
  } else if (window.document.addEventListener) {
    window.document.addEventListener("DOMContentLoaded", f, false);
  } else if (window.attachEvent) {
    window.attachEvent("onreadystatechange", function() {
      if (window.document.readyState == "complete") {
        f();
      }
    });
  } else {
    var oldLoad = window.onload;
    if (typeof(oldLoad) == "function") {
      window.onload = function() {
        try {
          oldLoad();
        } finally {
          f();
        }
      };
    } else {
      window.onload = f;
    }
  }
})(function() {
  // This is an ugly way to change the doctype, in case the scribble document
  // did not use (with-html5).
  if (!(document.doctype && document.doctype.publicId == '')) {
    if (console && console.log) {
      console.log("Re-wrote the document to use the HTML5 doctype.\n"
                  + "  Consider using the following declaration:\n"
                  + "      @title[#:style (with-html5 manual-doc-style)]{…}");
    }
    var wholeDoc = '<!doctype HTML>\n' + document.documentElement.outerHTML;
    document.open();
    document.clear();
    document.write(wholeDoc);
  }
  var inlineElements = document.getElementsByClassName("texMathInline");
  for (var i = 0; i < inlineElements.length; i++) {
    var e = inlineElements[i];
    katex.render(e.textContent, e, { displayMode:false, throwOnError:false });
  }
  var displayElements = document.getElementsByClassName("texMathDisplay");
  for (var i = 0; i < displayElements.length; i++) {
    var e = displayElements[i];
    katex.render(e.textContent, e, { displayMode:true, throwOnError:false });
  }
});
</script><script type="text/javascript" src="manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9660;</a></td><td></td><td><a href="index.html" class="tocviewlink" data-pltdoc="x">CMSC 388X:<span class="mywbr"> &nbsp;</span> Introduction to Programming Languages Research for Undergraduates</a></td></tr></table></div><div class="tocviewsublisttop" style="display: block;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right"></td><td><a href="Syllabus.html" class="tocviewlink" data-pltdoc="x">Syllabus</a></td></tr><tr><td align="right"></td><td><a href="Materials.html" class="tocviewlink" data-pltdoc="x">Materials</a></td></tr><tr><td align="right"></td><td><a href="" class="tocviewselflink" data-pltdoc="x">Defining Languages</a></td></tr><tr><td align="right"></td><td><a href="Papers.html" class="tocviewlink" data-pltdoc="x">Papers</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">&#9658;</a></td><td></td><td><a href="" class="tocviewselflink" data-pltdoc="x">Defining Languages</a></td></tr></table><div class="tocviewsublistbottom" style="display: none;" id="tocview_1"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="#%28part._.Syntax%29" class="tocviewlink" data-pltdoc="x">Syntax</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="#%28part._.Semantics%29" class="tocviewlink" data-pltdoc="x">Semantics</a></td></tr></table></div></div></div><div class="tocsub"><div class="tocsubtitle">On this page:</div><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber">1<tt>&nbsp;</tt></span><a href="#%28part._.Syntax%29" class="tocsubseclink" data-pltdoc="x">Syntax</a></td></tr><tr><td><span class="tocsublinknumber">1.1<tt>&nbsp;</tt></span><a href="#%28part._.Syntactic_.Terminology%29" class="tocsubseclink" data-pltdoc="x">Syntactic Terminology</a></td></tr><tr><td><span class="tocsublinknumber">1.2<tt>&nbsp;</tt></span><a href="#%28part._.Grammars%29" class="tocsubseclink" data-pltdoc="x">Grammars</a></td></tr><tr><td><span class="tocsublinknumber">1.2.1<tt>&nbsp;</tt></span><a href="#%28part._defining-lambda-calculus%29" class="tocsubseclink" data-pltdoc="x">A Grammar for the Lambda Calculus</a></td></tr><tr><td><span class="tocsublinknumber">1.3<tt>&nbsp;</tt></span><a href="#%28part._.Producing_.Syntax%29" class="tocsubseclink" data-pltdoc="x">Producing Syntax</a></td></tr><tr><td><span class="tocsublinknumber">2<tt>&nbsp;</tt></span><a href="#%28part._.Semantics%29" class="tocsubseclink" data-pltdoc="x">Semantics</a></td></tr><tr><td><span class="tocsublinknumber">2.1<tt>&nbsp;</tt></span><a href="#%28part._.Inference_.Rules%29" class="tocsubseclink" data-pltdoc="x">Inference Rules</a></td></tr><tr><td><span class="tocsublinknumber">2.2<tt>&nbsp;</tt></span><a href="#%28part._relations%29" class="tocsubseclink" data-pltdoc="x">Relations</a></td></tr><tr><td><span class="tocsublinknumber">2.3<tt>&nbsp;</tt></span><a href="#%28part._.A_.Semantics_for_the_.Lambda_.Calculus%29" class="tocsubseclink" data-pltdoc="x">A Semantics for the Lambda Calculus</a></td></tr><tr><td><span class="tocsublinknumber">2.4<tt>&nbsp;</tt></span><a href="#%28part._.Small-.Step_vs_.Big-.Step_.Semantics%29" class="tocsubseclink" data-pltdoc="x">Small-<wbr></wbr>Step vs Big-<wbr></wbr>Step Semantics</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="versionbox"><span class="version">8.3</span></div><div class="navsettop"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;<span class="tocsettoggle">&nbsp;&nbsp;<a href="javascript:void(0);" title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span></span><span class="navright">&nbsp;&nbsp;<a href="Materials.html" title="backward to &quot;Materials&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;CMSC 388X: Introduction to Programming Languages Research for Undergraduates&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="Papers.html" title="forward to &quot;Papers&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div><h3><a name="(part._.Defining_.Languages)"></a>Defining Languages</h3><p>Throughout this class, we will be reading and writing language definitions
quite frequently. To make this process easier, we should all be sure to have
the same terminology and tools.</p><h4>1<tt>&nbsp;</tt><a name="(part._.Syntax)"></a>Syntax</h4><p>When we define a programming language, we often first begin with some notion of
the language&rsquo;s
<a href="https://en.wikipedia.org/wiki/Syntax_(programming_languages)"><span class="emph">syntax</span></a>.
Syntax is what a language looks like or how it is written.</p><h5>1.1<tt>&nbsp;</tt><a name="(part._.Syntactic_.Terminology)"></a>Syntactic Terminology</h5><p>First, let&rsquo;s go over some quick definitions:</p><ul><li><p><span class="emph">symbol</span> &#8212;<wbr></wbr> Any atomic thing that can be written, such as letters
or numbers.</p></li><li><p><span class="emph">alphabet</span> &#8212;<wbr></wbr> A <span class="emph">set</span> of <span class="emph">symbols</span>.</p></li><li><p><span class="emph">string</span> &#8212;<wbr></wbr> A finite <span class="emph">sequence</span> of <span class="emph">symbols</span> from a
single <span class="emph">alphabet</span>. Sometimes also called a <span class="emph">word</span>.</p></li><li><p><a href="https://en.wikipedia.org/wiki/Formal_language"><span class="emph">language</span></a>
&#8212;<wbr></wbr> A <span class="emph">set</span> of <span class="emph">strings</span> composed from a single
<span class="emph">alphabet</span>.</p></li></ul><p>When defining a language, we <span class="emph">could</span> just stick to sets of strings, such
as <span class="stt">{foo, bar, baz}</span>. However, this is limiting in two ways:</p><ol><li><p>We can only write finite languages this way.</p></li><li><p>If the language grows even slightly, writing it becomes quite tedious.</p></li></ol><p>Instead, let&rsquo;s use <span class="emph">grammars</span>.</p><h5>1.2<tt>&nbsp;</tt><a name="(part._.Grammars)"></a>Grammars</h5><p>A <a href="https://en.wikipedia.org/wiki/Formal_grammar"><span class="emph">grammar</span></a> is a
set of rules that allow you to transform an abstract specification for a
language into a concrete string contained by that language. (This may feel a
bit abstract, so just hang tight and keep reading a bit further.)</p><p>There are various ways to write language grammars, but in this class we will
use a variant of what is known as
<a href="https://en.wikipedia.org/wiki/Extended_Backus–Naur_form">Extended
Backus-Naur Form</a>, or EBNF for short. Let&rsquo;s consider the EBNF grammar for EBNF
grammars:</p><p><table cellspacing="0" cellpadding="0"><tr><td valign="baseline"><p><span class="hspace">&nbsp;</span></p></td><td valign="baseline"><p><span style="font-weight: bold"><span class="stt">grammar</span></span></p></td><td valign="baseline"><p><span class="stt"><span class="hspace">&nbsp;</span>::=<span class="hspace">&nbsp;</span></span></p></td><td valign="baseline"><p><span style="font-weight: bold"><span class="stt">rule-list</span></span></p></td></tr><tr><td valign="baseline"><p><span class="hspace">&nbsp;</span></p></td><td valign="baseline"><p><span style="font-weight: bold"><span class="stt">rule-list</span></span></p></td><td valign="baseline"><p><span class="stt"><span class="hspace">&nbsp;</span>::=<span class="hspace">&nbsp;</span></span></p></td><td valign="baseline"><p><span style="font-weight: bold"><span class="stt">rule</span></span></p></td></tr><tr><td valign="baseline"><p><span class="hspace">&nbsp;</span></p></td><td valign="baseline"><p> </p></td><td valign="baseline"><p><span class="stt"><span class="hspace">&nbsp;</span><span class="hspace">&nbsp;</span>|<span class="hspace">&nbsp;</span><span class="hspace">&nbsp;</span></span></p></td><td valign="baseline"><p><span style="font-weight: bold"><span class="stt">rule</span></span><span class="hspace">&nbsp;</span><span class="RktInBG"><span class="hspace"></span><span class="RktIn">\n</span><span class="hspace"></span></span><span class="hspace">&nbsp;</span><span style="font-weight: bold"><span class="stt">rule-list</span></span></p></td></tr><tr><td valign="baseline"><p><span class="hspace">&nbsp;</span></p></td><td valign="baseline"><p><span style="font-weight: bold"><span class="stt">rule</span></span></p></td><td valign="baseline"><p><span class="stt"><span class="hspace">&nbsp;</span>::=<span class="hspace">&nbsp;</span></span></p></td><td valign="baseline"><p><span style="font-weight: bold"><span class="stt">metavariable</span></span><span class="hspace">&nbsp;</span><span class="RktInBG"><span class="hspace"></span><span class="RktIn">::=</span><span class="hspace"></span></span><span class="hspace">&nbsp;</span><span style="font-weight: bold"><span class="stt">production-list</span></span></p></td></tr><tr><td valign="baseline"><p><span class="hspace">&nbsp;</span></p></td><td valign="baseline"><p><span style="font-weight: bold"><span class="stt">metavariable</span></span></p></td><td valign="baseline"><p><span class="stt"><span class="hspace">&nbsp;</span>::=<span class="hspace">&nbsp;</span></span></p></td><td valign="baseline"><p><span style="font-style: italic">any symbol or string of symbols</span></p></td></tr><tr><td valign="baseline"><p><span class="hspace">&nbsp;</span></p></td><td valign="baseline"><p><span style="font-weight: bold"><span class="stt">production-list</span></span></p></td><td valign="baseline"><p><span class="stt"><span class="hspace">&nbsp;</span>::=<span class="hspace">&nbsp;</span></span></p></td><td valign="baseline"><p><span style="font-weight: bold"><span class="stt">production</span></span></p></td></tr><tr><td valign="baseline"><p><span class="hspace">&nbsp;</span></p></td><td valign="baseline"><p> </p></td><td valign="baseline"><p><span class="stt"><span class="hspace">&nbsp;</span><span class="hspace">&nbsp;</span>|<span class="hspace">&nbsp;</span><span class="hspace">&nbsp;</span></span></p></td><td valign="baseline"><p><span style="font-weight: bold"><span class="stt">production</span></span><span class="hspace">&nbsp;</span><span class="RktInBG"><span class="hspace"></span><span class="RktIn">|</span><span class="hspace"></span></span><span class="hspace">&nbsp;</span><span style="font-weight: bold"><span class="stt">production-list</span></span></p></td></tr><tr><td valign="baseline"><p><span class="hspace">&nbsp;</span></p></td><td valign="baseline"><p><span style="font-weight: bold"><span class="stt">production</span></span></p></td><td valign="baseline"><p><span class="stt"><span class="hspace">&nbsp;</span>::=<span class="hspace">&nbsp;</span></span></p></td><td valign="baseline"><p><span style="font-weight: bold"><span class="stt">metavariable</span></span></p></td></tr><tr><td valign="baseline"><p><span class="hspace">&nbsp;</span></p></td><td valign="baseline"><p> </p></td><td valign="baseline"><p><span class="stt"><span class="hspace">&nbsp;</span><span class="hspace">&nbsp;</span>|<span class="hspace">&nbsp;</span><span class="hspace">&nbsp;</span></span></p></td><td valign="baseline"><p><span style="font-weight: bold"><span class="stt">terminal</span></span></p></td></tr><tr><td valign="baseline"><p><span class="hspace">&nbsp;</span></p></td><td valign="baseline"><p> </p></td><td valign="baseline"><p><span class="stt"><span class="hspace">&nbsp;</span><span class="hspace">&nbsp;</span>|<span class="hspace">&nbsp;</span><span class="hspace">&nbsp;</span></span></p></td><td valign="baseline"><p><span style="font-weight: bold"><span class="stt">production</span></span><span class="hspace">&nbsp;</span><span style="font-weight: bold"><span class="stt">production</span></span></p></td></tr><tr><td valign="baseline"><p><span class="hspace">&nbsp;</span></p></td><td valign="baseline"><p> </p></td><td valign="baseline"><p><span class="stt"><span class="hspace">&nbsp;</span><span class="hspace">&nbsp;</span>|<span class="hspace">&nbsp;</span><span class="hspace">&nbsp;</span></span></p></td><td valign="baseline"><p><span style="font-weight: bold"><span class="stt">production</span></span><span class="hspace">&nbsp;</span><span class="RktInBG"><span class="hspace"></span><span class="RktIn">|</span><span class="hspace"></span></span><span class="hspace">&nbsp;</span><span style="font-weight: bold"><span class="stt">production</span></span></p></td></tr><tr><td valign="baseline"><p><span class="hspace">&nbsp;</span></p></td><td valign="baseline"><p> </p></td><td valign="baseline"><p><span class="stt"><span class="hspace">&nbsp;</span><span class="hspace">&nbsp;</span>|<span class="hspace">&nbsp;</span><span class="hspace">&nbsp;</span></span></p></td><td valign="baseline"><p><span class="RktInBG"><span class="hspace"></span><span class="RktIn">(</span><span class="hspace"></span></span><span class="hspace">&nbsp;</span><span style="font-weight: bold"><span class="stt">production</span></span><span class="hspace">&nbsp;</span><span class="RktInBG"><span class="hspace"></span><span class="RktIn">)</span><span class="hspace"></span></span></p></td></tr><tr><td valign="baseline"><p><span class="hspace">&nbsp;</span></p></td><td valign="baseline"><p><span style="font-weight: bold"><span class="stt">terminal</span></span></p></td><td valign="baseline"><p><span class="stt"><span class="hspace">&nbsp;</span>::=<span class="hspace">&nbsp;</span></span></p></td><td valign="baseline"><p><span style="font-style: italic">any symbol or string of symbols that may exist in the
language</span></p></td></tr></table></p><p>This tells us that a <span style="font-weight: bold"><span class="stt">grammar</span></span> consists of a list of one or more
<span style="font-weight: bold"><span class="stt">rule</span></span>s, each of which has three parts: (1) a <span style="font-weight: bold"><span class="stt">metavariable</span></span>,
which is used as the name of the rule; (2) the symbol <span class="stt">::=</span>; and (3) a list
of one or more <span style="font-weight: bold"><span class="stt">production</span></span>s.</p><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p><span style="font-weight: bold">What is a metavariable?</span></p><p>A <span class="emph">metavariable</span>, also called a <span class="emph">metasyntactic variable</span>, is a word
or symbol that stands for other words or symbols. In the same way that we use
letters like <span class="emph">x</span> to represent numbers in algebra, we can use letters or
words in grammars to represent rules in the grammar.</p></blockquote></blockquote></blockquote><p>The <span style="font-weight: bold"><span class="stt">metavariable</span></span> can be written as any word or symbol that you care to
write. This word or symbol is not itself part of the langauge; it&rsquo;s just a way
to reference rules in the grammar. Notice that in the grammar, we describe this
property using italicized text.</p><p>A <span style="font-weight: bold"><span class="stt">production</span></span> is a recipe for how to <span class="emph">expand</span> a metavariable. In
the same way that you might substitute the variable <span class="emph">x</span> with an actual
number in an algebraic expression, you can substitute metavariables with one of
their productions when you want to construct a string in the language to which
the grammar corresponds. (We will do some examples of this in a bit, so hang
tight if this doesn&rsquo;t quite make sense yet!)</p><p>There are a few kinds of productions you can write. The simplest one is to
replace the metavariable to which the production corresponds with a
<span style="font-weight: bold"><span class="stt">literal</span></span>. A literal is any symbol or string of symbols that are part of
the language. If we were talking about the language of arithmetic expressions
(like <span class="stt">1 + 1</span> or <span class="stt">6 x 9</span>), the list of literals used would include
<span class="RktInBG"><span class="hspace"></span><span class="RktIn">1</span><span class="hspace"></span></span>, <span class="RktInBG"><span class="hspace"></span><span class="RktIn">6</span><span class="hspace"></span></span>, <span class="RktInBG"><span class="hspace"></span><span class="RktIn">9</span><span class="hspace"></span></span>, <span class="RktInBG"><span class="hspace"></span><span class="RktIn">+</span><span class="hspace"></span></span>, and <span class="RktInBG"><span class="hspace"></span><span class="RktIn">x</span><span class="hspace"></span></span>. These are
symbols that cannot be expanded to anything else.</p><p>In addition to literals, there are also <span class="emph">non-literals</span>: rules! When you
see a metavariable in a production, it represents another part of the grammar.
Variables in algebra are also non-literals, so the expression <span class="stt">x + 1</span>
contains the non-literal <span class="stt">x</span> and the two literals <span class="RktInBG"><span class="hspace"></span><span class="RktIn">+</span><span class="hspace"></span></span> and
<span class="RktInBG"><span class="hspace"></span><span class="RktIn">1</span><span class="hspace"></span></span>.</p><p>The next kind of production is one which points to another rule by using a
metavariable. Although you could hypothetically write anything and call it a
metavariable, a grammar is only considered to be well-formed ("useful") if the
metavariables used in productions are defined as rules in the same grammar.</p><p>Next, productions can be sequences of other productions. (Yes, rules can
reference themselves recursively!)</p><p>You can also provide multiple alternate productions using <span class="RktInBG"><span class="hspace"></span><span class="RktIn">|</span><span class="hspace"></span></span>. This is
the same as if you were to write multiple rules with the same metavariable. It
means that, whenever you encounter that metavariable, you can use any one of
the associated productions.</p><p>Lastly, a production can be a production wrapped in parentheses. This is useful
if you want to provide sequences or alternates within a larger production.</p><h5>1.2.1<tt>&nbsp;</tt><a name="(part._defining-lambda-calculus)"></a>A Grammar for the Lambda Calculus</h5><p>To give another example, let&rsquo;s consider an EBNF grammar for the
<a href="https://en.wikipedia.org/wiki/Lambda_calculus">lambda calculus</a>:</p><p><table cellspacing="0" cellpadding="0"><tr><td valign="baseline"><p><span class="hspace">&nbsp;</span></p></td><td valign="baseline"><p><span style="font-weight: bold"><span class="stt">x</span></span></p></td><td valign="baseline"><p><span class="stt"><span class="hspace">&nbsp;</span>::=<span class="hspace">&nbsp;</span></span></p></td><td valign="baseline"><p><span style="font-style: italic">any variable name</span></p></td></tr><tr><td valign="baseline"><p><span class="hspace">&nbsp;</span></p></td><td valign="baseline"><p><span style="font-weight: bold"><span class="stt">e</span></span></p></td><td valign="baseline"><p><span class="stt"><span class="hspace">&nbsp;</span>::=<span class="hspace">&nbsp;</span></span></p></td><td valign="baseline"><p><span style="font-weight: bold"><span class="stt">x</span></span></p></td></tr><tr><td valign="baseline"><p><span class="hspace">&nbsp;</span></p></td><td valign="baseline"><p> </p></td><td valign="baseline"><p><span class="stt"><span class="hspace">&nbsp;</span><span class="hspace">&nbsp;</span>|<span class="hspace">&nbsp;</span><span class="hspace">&nbsp;</span></span></p></td><td valign="baseline"><p><span class="RktInBG"><span class="hspace"></span><span class="RktIn">(</span><span class="hspace"></span></span><span class="hspace">&nbsp;</span><span style="font-weight: bold"><span class="stt">e</span></span><span class="hspace">&nbsp;</span><span style="font-weight: bold"><span class="stt">e</span></span><span class="hspace">&nbsp;</span><span class="RktInBG"><span class="hspace"></span><span class="RktIn">)</span><span class="hspace"></span></span></p></td></tr><tr><td valign="baseline"><p><span class="hspace">&nbsp;</span></p></td><td valign="baseline"><p> </p></td><td valign="baseline"><p><span class="stt"><span class="hspace">&nbsp;</span><span class="hspace">&nbsp;</span>|<span class="hspace">&nbsp;</span><span class="hspace">&nbsp;</span></span></p></td><td valign="baseline"><p><span class="RktInBG"><span class="hspace"></span><span class="RktIn">(</span><span class="hspace"></span></span><span class="hspace">&nbsp;</span><span class="RktInBG"><span class="hspace"></span><span class="RktIn">&#955;</span><span class="hspace"></span></span><span class="hspace">&nbsp;</span><span class="RktInBG"><span class="hspace"></span><span class="RktIn">(</span><span class="hspace"></span></span><span class="hspace">&nbsp;</span><span style="font-weight: bold"><span class="stt">x</span></span><span class="hspace">&nbsp;</span><span class="RktInBG"><span class="hspace"></span><span class="RktIn">)</span><span class="hspace"></span></span><span class="hspace">&nbsp;</span><span style="font-weight: bold"><span class="stt">e</span></span><span class="hspace">&nbsp;</span><span class="RktInBG"><span class="hspace"></span><span class="RktIn">)</span><span class="hspace"></span></span></p></td></tr><tr><td valign="baseline"><p><span class="hspace">&nbsp;</span></p></td><td valign="baseline"><p><span style="font-weight: bold"><span class="stt">v</span></span></p></td><td valign="baseline"><p><span class="stt"><span class="hspace">&nbsp;</span>::=<span class="hspace">&nbsp;</span></span></p></td><td valign="baseline"><p><span class="RktInBG"><span class="hspace"></span><span class="RktIn">(</span><span class="hspace"></span></span><span class="hspace">&nbsp;</span><span class="RktInBG"><span class="hspace"></span><span class="RktIn">&#955;</span><span class="hspace"></span></span><span class="hspace">&nbsp;</span><span class="RktInBG"><span class="hspace"></span><span class="RktIn">(</span><span class="hspace"></span></span><span class="hspace">&nbsp;</span><span style="font-weight: bold"><span class="stt">x</span></span><span class="hspace">&nbsp;</span><span class="RktInBG"><span class="hspace"></span><span class="RktIn">)</span><span class="hspace"></span></span><span class="hspace">&nbsp;</span><span style="font-weight: bold"><span class="stt">e</span></span><span class="hspace">&nbsp;</span><span class="RktInBG"><span class="hspace"></span><span class="RktIn">)</span><span class="hspace"></span></span></p></td></tr></table></p><p>The first rule, named <span style="font-weight: bold"><span class="stt">x</span></span>, corresponds to variable names. The italic
text to the right of the <span class="stt">::=</span> symbol is meant to be read literally rather
than as a mathematical concept. Whatever you think "any variable name" means,
that&rsquo;s how we&rsquo;ve defined <span style="font-weight: bold"><span class="stt">x</span></span>.</p><p>The second rule, <span style="font-weight: bold"><span class="stt">e</span></span>, corresponds to <span class="emph">expressions</span>. According to
this grammar, an expression can be one of three things:</p><ul><li><p>A variable (shown using the metavariable <span style="font-weight: bold"><span class="stt">x</span></span>). Some langauges
may choose to constrain what exactly a "variable" may be, but for our
purposes right now we will simply allow any string of letters that are
not used as literals in the grammar, which in this case is just &#955;
(lambda).</p></li><li><p>A sequence consisting of: a literal left parenthesis, an expression, a
second expression, and a literal right parenthesis. Note that the two
inner expressions do not need to be the same. This rule is often called
<span class="emph">application</span>.</p></li><li><p>A sequence consisting of: a literal left parenthesis, a literal lambda
character, a literal left parenthesis, any variable, a literal right
parenthesis, any expression, and a literal right parenthesis. This rule
is often called <span class="emph">abstraction</span>, <span class="emph">function</span>, or <span class="emph">lambda</span>.</p></li></ul><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p>We will come back to the distinction between <span class="emph">expressions</span>
and <span class="emph">values</span> when we discuss semantics.</p></blockquote></blockquote></blockquote><p>The third and final rule, <span style="font-weight: bold"><span class="stt">v</span></span>, corresponds to <span class="emph">values</span>. In this
grammar, we define values to be identical to <span class="emph">abstractions</span> from the
expressions.</p><h5>1.3<tt>&nbsp;</tt><a name="(part._.Producing_.Syntax)"></a>Producing Syntax</h5><p>Once a grammar has been established, it can be used to generate strings in the
corresponding langauge. To start building productions, you start at a
non-terminal. Let&rsquo;s start with the rule for expressions, <span style="font-weight: bold"><span class="stt">e</span></span>, from our
grammar for the lambda calculus, and expand the non-terminals until we get to a
sequence of terminals.</p><ul><li><p><span style="font-weight: bold"><span class="stt">e</span></span></p></li><li><p><span class="RktInBG"><span class="hspace"></span><span class="RktIn">(</span><span class="hspace"></span></span> <span style="font-weight: bold"><span class="stt">e</span></span> <span style="font-weight: bold"><span class="stt">e</span></span> <span class="RktInBG"><span class="hspace"></span><span class="RktIn">)</span><span class="hspace"></span></span></p></li><li><p><span class="RktInBG"><span class="hspace"></span><span class="RktIn">(</span><span class="hspace"></span></span> <span class="RktInBG"><span class="hspace"></span><span class="RktIn">(</span><span class="hspace"></span></span> <span class="RktInBG"><span class="hspace"></span><span class="RktIn">&#955;</span><span class="hspace"></span></span> <span class="RktInBG"><span class="hspace"></span><span class="RktIn">(</span><span class="hspace"></span></span> <span style="font-weight: bold"><span class="stt">x</span></span> <span class="RktInBG"><span class="hspace"></span><span class="RktIn">)</span><span class="hspace"></span></span>
<span style="font-weight: bold"><span class="stt">e</span></span> <span class="RktInBG"><span class="hspace"></span><span class="RktIn">)</span><span class="hspace"></span></span> <span style="font-weight: bold"><span class="stt">e</span></span> <span class="RktInBG"><span class="hspace"></span><span class="RktIn">)</span><span class="hspace"></span></span></p></li><li><p><span class="RktInBG"><span class="hspace"></span><span class="RktIn">(</span><span class="hspace"></span></span> <span class="RktInBG"><span class="hspace"></span><span class="RktIn">(</span><span class="hspace"></span></span> <span class="RktInBG"><span class="hspace"></span><span class="RktIn">&#955;</span><span class="hspace"></span></span> <span class="RktInBG"><span class="hspace"></span><span class="RktIn">(</span><span class="hspace"></span></span> <span class="RktInBG"><span class="hspace"></span><span class="RktIn">x</span><span class="hspace"></span></span> <span class="RktInBG"><span class="hspace"></span><span class="RktIn">)</span><span class="hspace"></span></span>
<span style="font-weight: bold"><span class="stt">e</span></span> <span class="RktInBG"><span class="hspace"></span><span class="RktIn">)</span><span class="hspace"></span></span> <span style="font-weight: bold"><span class="stt">e</span></span> <span class="RktInBG"><span class="hspace"></span><span class="RktIn">)</span><span class="hspace"></span></span></p></li><li><p><span class="RktInBG"><span class="hspace"></span><span class="RktIn">(</span><span class="hspace"></span></span> <span class="RktInBG"><span class="hspace"></span><span class="RktIn">(</span><span class="hspace"></span></span> <span class="RktInBG"><span class="hspace"></span><span class="RktIn">&#955;</span><span class="hspace"></span></span> <span class="RktInBG"><span class="hspace"></span><span class="RktIn">(</span><span class="hspace"></span></span> <span class="RktInBG"><span class="hspace"></span><span class="RktIn">x</span><span class="hspace"></span></span> <span class="RktInBG"><span class="hspace"></span><span class="RktIn">)</span><span class="hspace"></span></span>
<span style="font-weight: bold"><span class="stt">x</span></span> <span class="RktInBG"><span class="hspace"></span><span class="RktIn">)</span><span class="hspace"></span></span> <span style="font-weight: bold"><span class="stt">e</span></span> <span class="RktInBG"><span class="hspace"></span><span class="RktIn">)</span><span class="hspace"></span></span></p></li><li><p><span class="RktInBG"><span class="hspace"></span><span class="RktIn">(</span><span class="hspace"></span></span> <span class="RktInBG"><span class="hspace"></span><span class="RktIn">(</span><span class="hspace"></span></span> <span class="RktInBG"><span class="hspace"></span><span class="RktIn">&#955;</span><span class="hspace"></span></span> <span class="RktInBG"><span class="hspace"></span><span class="RktIn">(</span><span class="hspace"></span></span> <span class="RktInBG"><span class="hspace"></span><span class="RktIn">x</span><span class="hspace"></span></span> <span class="RktInBG"><span class="hspace"></span><span class="RktIn">)</span><span class="hspace"></span></span>
<span class="RktInBG"><span class="hspace"></span><span class="RktIn">x</span><span class="hspace"></span></span> <span class="RktInBG"><span class="hspace"></span><span class="RktIn">)</span><span class="hspace"></span></span> <span style="font-weight: bold"><span class="stt">e</span></span> <span class="RktInBG"><span class="hspace"></span><span class="RktIn">)</span><span class="hspace"></span></span></p></li><li><p><span class="RktInBG"><span class="hspace"></span><span class="RktIn">(</span><span class="hspace"></span></span> <span class="RktInBG"><span class="hspace"></span><span class="RktIn">(</span><span class="hspace"></span></span> <span class="RktInBG"><span class="hspace"></span><span class="RktIn">&#955;</span><span class="hspace"></span></span> <span class="RktInBG"><span class="hspace"></span><span class="RktIn">(</span><span class="hspace"></span></span> <span class="RktInBG"><span class="hspace"></span><span class="RktIn">x</span><span class="hspace"></span></span> <span class="RktInBG"><span class="hspace"></span><span class="RktIn">)</span><span class="hspace"></span></span>
<span class="RktInBG"><span class="hspace"></span><span class="RktIn">x</span><span class="hspace"></span></span> <span class="RktInBG"><span class="hspace"></span><span class="RktIn">)</span><span class="hspace"></span></span> <span style="font-weight: bold"><span class="stt">x</span></span> <span class="RktInBG"><span class="hspace"></span><span class="RktIn">)</span><span class="hspace"></span></span></p></li><li><p><span class="RktInBG"><span class="hspace"></span><span class="RktIn">(</span><span class="hspace"></span></span> <span class="RktInBG"><span class="hspace"></span><span class="RktIn">(</span><span class="hspace"></span></span> <span class="RktInBG"><span class="hspace"></span><span class="RktIn">&#955;</span><span class="hspace"></span></span> <span class="RktInBG"><span class="hspace"></span><span class="RktIn">(</span><span class="hspace"></span></span> <span class="RktInBG"><span class="hspace"></span><span class="RktIn">x</span><span class="hspace"></span></span> <span class="RktInBG"><span class="hspace"></span><span class="RktIn">)</span><span class="hspace"></span></span>
<span class="RktInBG"><span class="hspace"></span><span class="RktIn">x</span><span class="hspace"></span></span> <span class="RktInBG"><span class="hspace"></span><span class="RktIn">)</span><span class="hspace"></span></span> <span class="RktInBG"><span class="hspace"></span><span class="RktIn">y</span><span class="hspace"></span></span> <span class="RktInBG"><span class="hspace"></span><span class="RktIn">)</span><span class="hspace"></span></span></p></li></ul><p>We can see from this process that generating a string from a grammar involves a
sequence of <span class="emph">rewriting steps</span> (also called <span class="emph">substitutions</span>). You
start with a non-terminal, then rewrite that non-terminal with one of its
productions, then continue rewriting the non-terminals generated from those
productions until you end up with a string that consists of only terminals.
(Although not strictly necessary, it is typical to expand the non-terminals
from left to right, as we did in the above example.)</p><h4>2<tt>&nbsp;</tt><a name="(part._.Semantics)"></a>Semantics</h4><p>Where a syntax tells us what a language looks like, a <span class="emph">semantics</span> tells us
what a language <span class="emph">means</span>.</p><p>There are a few schools of thought regarding how we can specify the meaning of
programming languages, but in this class we will only concern ourselves with
the technique called
<a href="https://en.wikipedia.org/wiki/Operational_semantics"><span class="emph">operational
semantics</span></a> (and, later, we will discuss an extension of operational semantics
called <span class="emph">reduction semantics</span>). In operational semantics, the meaning of a
programming language is described by rules that repeatedly transform the
program&rsquo;s syntax until you get to a final result.</p><h5>2.1<tt>&nbsp;</tt><a name="(part._.Inference_.Rules)"></a>Inference Rules</h5><p>The rules used in operational semantics are called
<a href="https://en.wikipedia.org/wiki/Rule_of_inference"><span class="emph">inference
rules</span></a> or <span class="emph">judgment forms</span> (though we will mostly refer to them as
"inference rules"). In general, an inference rule looks like this:</p><p><span class="texMathDisplay">premise_1\quad premise_2\quad\cdots\quad premise_n \over conclusion</span></p><p>We read the premises from left to right, then the conclusion. We can imagine an
inference rule says to us "if you can show evidence for all of the premises,
then you can assume the conclusion is true." Using inference rules, we can
construct a <a href="https://en.wikipedia.org/wiki/Formal_proof"><span class="emph">proof</span></a>
for a desired conclusion by working our way backwards from the bottom to the
top. But where would the tree end?</p><p>Sometimes, the list of premises is empty and you&rsquo;ll just see a line with a
conclusion:</p><p><span class="texMathDisplay">\vphantom{premise} \over conclusion</span></p><p>Such rules are called
<a href="https://en.wikipedia.org/wiki/Axiom"><span class="emph">axioms</span></a> because we can
assume their conclusions without needing any prior information. A
well-constructed proof built of inference rules should end with only axioms at
the top. (We&rsquo;ll show an example of a completed proof in a little bit.)</p><h5>2.2<tt>&nbsp;</tt><a name="(part._relations)"></a>Relations</h5><p>Almost always, inference rules are written to show the properties of some kind
of
<a href="https://en.wikipedia.org/wiki/Relation_(mathematics)"><span class="emph">relation</span></a>.
A relation is a way of saying how two things are connected. You probably
already know a lot of binary relations! For example, the addition operation
(<span class="texMathInline">+</span>) relates numbers and the conjunction operation (<span class="texMathInline">\land</span>) relates
Boolean values.</p><p>When defining an operational semantics for a programming language, we will
often define one of two operators (or, sometimes, both): <span class="texMathInline">\rightarrow</span> and
<span class="texMathInline">\Downarrow</span>. Traditionally, the <span class="texMathInline">\rightarrow</span> operator is used for what
are called <span class="emph">small-step</span> semantics, while the <span class="texMathInline">\Downarrow</span> operator is
used for <span class="emph">big-step</span> semantics. We will elaborate on the typical
differences between these relations later, but they both share a key attribute
in common: they describe <span class="emph">syntactic transformations</span>. Let&rsquo;s look at what
that means using an example.</p><h5>2.3<tt>&nbsp;</tt><a name="(part._.A_.Semantics_for_the_.Lambda_.Calculus)"></a>A Semantics for the Lambda Calculus</h5><p>Let&rsquo;s start by taking a look at an operational semantics for the lambda
calculus, using <a href="#%28part._defining-lambda-calculus%29" data-pltdoc="x">the syntax defined
previously</a>:</p><blockquote class="SCentered"><table cellspacing="0" cellpadding="0"><tr><td align="right"><p><span class="texMathDisplay">\vphantom{M} \over ((\lambda\ (x)\ e)\ v)\ \rightarrow\ e[x/v]</span></p></td><td align="right"><p><span class="hspace">&nbsp;</span></p></td><td align="left"><p>E-App</p></td></tr><tr><td align="right"><p><span class="texMathDisplay">e_1\ \rightarrow\ e_1{}&rsquo; \over (e_1\ e_2)\ \rightarrow\ (e_1{}&rsquo;\ e_2)</span></p></td><td align="right"><p><span class="hspace">&nbsp;</span></p></td><td align="left"><p>E-Arg1</p></td></tr><tr><td align="right"><p><span class="texMathDisplay">e\ \rightarrow\ e{}&rsquo; \over (v\ e)\ \rightarrow\ (v\ e{}&rsquo;)</span></p></td><td align="right"><p><span class="hspace">&nbsp;</span></p></td><td align="left"><p>E-Arg2</p></td></tr></table></blockquote><p>This semantics for the lambda calculus defines three rules: E-App, E-Arg1, and
E-Arg2.</p><p>First, let&rsquo;s notice that the first rule, E-App, is axiomatic, meaning it has no
premises. Second, we should notice that these rules all use the <span class="texMathInline">\rightarrow</span>
relation. Hopefully, this means we have written a small-step semantics, but
we&rsquo;ll come back to how to check that later.</p><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p><span style="font-weight: bold">Substitution Notation</span></p><p>Unfortunately, there is not a single universally agreed-upon notation for
substitution. <span class="texMathInline">e[x/v]</span> may be the most popular, but you may also see
<span class="texMathInline">e[x\backslash v]</span>, <span class="texMathInline">e[v/x]</span>, <span class="texMathInline">e[v\backslash x]</span>, <span class="texMathInline">e[x\mapsto v]</span>,
<span class="texMathInline">e[x := v]</span>, or another similar variation.</p></blockquote></blockquote></blockquote><p>E-App tells us that if we have the syntactic form <span class="texMathInline">((\lambda\ (x)\ e)\ v)</span>,
we can transform it to <span class="texMathInline">e[x/v]</span>, which is the notation for
<span class="emph">substitution</span>. What it means is that you should take the <span class="texMathInline">e</span> from
inside the lambda-expression on the left, but replace all occurrences of the
variable <span class="texMathInline">x</span> with the value <span class="texMathInline">v</span>. This process is called
<a href="https://en.wikipedia.org/wiki/Lambda_calculus#β-reduction"><span class="texMathInline">\beta</span>-reduction</a>
("beta-reduction").</p><p>E-Arg1 and E-Arg2 both have to do with reducing the components of an
application. A good question to ask might be: given some application form, how
do we know which rule to use? This is where our metavariables play an important
roll: if the component on the left is a value <span class="texMathInline">v</span>, we use E-Arg2. Otherwise,
we use E-Arg1. Or, to put it another way: we must use E-Arg1 repeatedly on the
application form until we have an application with a value <span class="texMathInline">v</span> on the left,
at which point we use E-Arg2 until we have two values. Once both components of
the application form are values (i.e., our application has the form <span class="texMathInline">(v_1\
v_2)</span>), we can use the E-App rule.</p><p>With these three rules, we have defined the small-step reduction relation
<span class="texMathInline">\rightarrow</span> for the lambda calculus.</p><h5>2.4<tt>&nbsp;</tt><a name="(part._.Small-.Step_vs_.Big-.Step_.Semantics)"></a>Small-Step vs Big-Step Semantics</h5><p><a href="#%28part._relations%29" data-pltdoc="x">Earlier</a>, we mentioned that there are two common
reduction relations used for operational semantics: small-step <span class="texMathInline">\rightarrow</span>
and big-step <span class="texMathInline">\Downarrow</span>. So what&rsquo;s the difference?</p><p>In a small-step semantics, we write our rules so that they only do one thing at
a time. This means we will often need to write many rules for some operations.
In our lambda calculus example, we needed three rules to explain what to do
with the application form <span class="texMathInline">(e\ e)</span>! The advantage of this style of semantics
is that it is very easy to see how the language works, because everything is
separated in such a way to highlight all the nuances. However,
<span class="emph">implementing</span> a small-step semantics can be quite painful, as we&rsquo;ll see
during the semester.</p><p>The alternative is a big-step semantics, wherein we take a few large steps
instead of many tiny steps. Here&rsquo;s an example of a big-step semantics for the
lambda calculus:</p><blockquote class="SCentered"><table cellspacing="0" cellpadding="0"><tr><td align="right"><p><span class="texMathDisplay">e_1\ \Downarrow\ (\lambda\ (x)\ e_3)\qquad e_2\ \Downarrow\ v_2\qquad e_3[x/v_2]\ \Downarrow\ v_3 \over (e_1\ e_2)\ \Downarrow\ v_3</span></p></td><td align="right"><p><span class="hspace">&nbsp;</span></p></td><td align="left"><p>E-App</p></td></tr></table></blockquote><p>This semantics only needs one rule! It can be read in English as something like
"if <span class="texMathInline">e_1</span> reduces by the big-step relation <span class="texMathInline">\Downarrow</span> to a
lambda-expression, <span class="texMathInline">e_2</span> reduces to any value, and the beta-reduction of
those terms results in a value <span class="texMathInline">v_3</span>, then the application <span class="texMathInline">(e_1\ e_2)</span>
reduces to the value <span class="texMathInline">v_3</span>."</p><p>So how can we tell the difference between small-step and big-step semantics,
other than the arrow operator used? In a big-step semantics, each reduction
evaluates <span class="emph">fully</span> to a value. In contrast, the rules in our small-step
semantics above can produce non-value terms.</p><p>Often, it is useful to define both kinds of semantics for a language. The
small-step semantics is used on paper, while the big-step semantics is used for
implementing an interpreter for the language. We will see both of these
throughout this class.</p><div class="navsetbottom"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;<span class="tocsettoggle">&nbsp;&nbsp;<a href="javascript:void(0);" title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span></span><span class="navright">&nbsp;&nbsp;<a href="Materials.html" title="backward to &quot;Materials&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;CMSC 388X: Introduction to Programming Languages Research for Undergraduates&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="Papers.html" title="forward to &quot;Papers&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>